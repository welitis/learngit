1. 添加文件到Git仓库步骤
 1. git add filename # 添加文件
 2. git commit -m <message 提交说明信息>

2. Git初始化
 进入要初始化的文件夹输入git init

3. 查看工作区的状态
 git status

4. 比较文件与修改前的不同在add之前
 git diff <filename>

5. 返回其他版本状态
 git reset --hard <commit_id>(不用写全部，前几个字母就可以)

6. 查看历史版本
 git log/git log --pretty=oneline

7. 查看历史命令，回到未来
 git reflog

## 血泪教训
在没有提交到master的情况下不要随便的切换版本，不然暂存库的东西就不见了呀，还想着等全部写完再一起提交的，结果突发奇想试了一下版本切换，这下可好，一早上的笔记就这样不见了~ 

# git diff <filename> 是比较文件在工作区和暂存区的区别，即便暂存区没有文件，全部提交了，依然是比较上一次该文件在暂存库的状态。
git diff --cached 是比较暂存区和版本库的不同
git diff HEAD -- <filename> 是比较文件在工作区和版本库的不同

8. 删除对工作区的修改，与暂存区的区别
git checkout -- <filename>

9. 撤销暂存区的文件
git reset HEAD <filename>

10. 删除版本库的文件,并且需要提交，创建一个新的版本，也就是删除了文件的版本
git rm <filename>

11. 恢复工作区删除的文件，只要版本库有备份就可以恢复
git checkout -- <filename>

git checkout -- <filename>的两个作用
1. 在工作区文件被删除的情况下，从版本库中还原文件
2. 在工作区对文件作出修改未commit的情况下，可以恢复工作区文件到上一次暂存区的文件状态，比如：在工作区对a文件进行修改并add到暂存区，接着又对a文件修改了，如果此时使用该命令，那么会将文件a恢复至暂存区a文件的状态，如果暂存区没有文件，那就是上一次commit前的add a文件的状态，也就是版本库最新版本中a文件的状态。
感觉这两个作用原理都是差不多的，都是从暂存库中还原文件，我觉得可以这样理解，第一个作用，删除文件后从版本库中恢复文件，也就是从上次这个文件在的暂存库中恢复该文件，第二个作用也是同理，从上次这个文件在的暂存库中恢复文件到工作区，在文件a修改后，或者已经add后，checkout会找到这个文件上次在暂存库的状态，然后恢复过去。

12. 关联一个远程库,需要先在GitHub创建一个repository
git remote add origin（远程库的名字） git@server-name:path/repo-name.git

13. 第一次推送master分支的所有内容
git push -u origin master
git push origin master

14. 克隆仓库只需要直到仓库的地址,没有用户限制,git支持多种协议，包括https，但通过ssh支持的原生git协议最快
git clone git@github.com:welitis/<repo name>.git

15. 分支的创建、合并、删除
查看分支
git branch
创建分支
git branch <branch name>
切换分支
git checkout <branch name>
创建+切换分支
git checkout -b <branch name>
合并某分支到当前分支
git merge <branch name>
删除分支
git branch -d <branch name>
Git鼓励大量用分支 

彻底觉醒
git创建分支只是多了一个指向该工作区的方向而已，比如当前工作区有三个分支a,b,master,如果在a中操作了工作区内容并add那么在其他分支也能查看到，因为他们都是指向同一个工作区嘛，而且暂存区的内容也是公用的，最重要的就是如果在分支a操作过程中提交到暂存区的文件，在另外一个分支commit了，那a分支暂存区也什么也没有了，修改的所有内容都没了，都被另外一个分支偷走了

当git无法自动合并分支时，就必须解决冲突，再提交，合并完成
解决冲突就是把Git合并失败的文件手动挡编辑为我们希望的内容，再提交
用git log --graph=pretty=oneline --abbrev-commit
